/*
function ReplaceStringFunc(s,fs,ts)
  if Type(fs) eq SeqEnum then
    for i:=1 to #fs do
      s:=ReplaceStringFunc(s,fs[i],ts[i]);
    end for;
    return s;
  end if;
  s:=CodeToString(255) cat Sprint(s) cat CodeToString(255);
  while Position(s,fs) ne 0 do
    p:=Position(s,fs);
    p:=[p-1,#fs,#s-p-#fs+1];
    s1,s2,s3:=Explode(Partition(Eltseq(s),p));
    s:=&cat(s1) cat ts cat &cat(s3);
  end while;
  return s[[2..#s-1]];
end function;
*/

intrinsic ReplaceString(s::MonStgElt, fs::MonStgElt, ts::MonStgElt) -> MonStgElt
    {Return a string obtained from the string s by replacing all occurences of the SINGLE character fs with ts.}
    assert #fs eq 1;
    L := Split(s, fs);
    // Split doesn't deal with fs at the beginning or end of the string correctly.
    if s[1] eq fs then Insert(~L, 1, ""); end if;
    if s[#s] eq fs then Append(~L, ""); end if;
    return Join(L, ts);
end intrinsic;

intrinsic ReplaceString(s::MonStgElt, fs::[MonStgElt], ts::[MonStgElt]) -> MonStgElt
{Return a string obtained from the string s by replacing all occurences of strings in fs with strings in ts.}
    // assert not (true in [ts[i] in s : i in [1..#ts]]);
    for i:=1 to #fs do
        s:=ReplaceString(s,fs[i],ts[i]);
    end for;
    return s;
end intrinsic;

intrinsic PySplit(s::MonStgElt, sep::MonStgElt : limit:=-1) -> SeqEnum[MonStgElt]
{Splits using Python semantics (different when #sep > 1, and different when sep at beginning or end)}
    if #sep eq 0 then
        error "Empty separator";
    elif #sep eq 1 then
        // Magma's built in Split is faster here
        return Split(s, sep: IncludeEmpty) cat (s[#s] eq sep select [""] else []);
    end if;
    i := 1;
    j := 0;
    ans := [];
    while limit gt 0 or limit eq -1 do
        if limit ne -1 then limit -:= 1; end if;
        pos := Index(s, sep, i);
        if pos eq 0 then break; end if;
        j := pos - 1;
        Append(~ans, s[i..j]);
        i := j + #sep + 1;
    end while;
    Append(~ans, s[i..#s]);
    return ans;
end intrinsic;

// procedure versions
intrinsic ReplaceString(~s::MonStgElt, fs::MonStgElt, ts::MonStgElt)
  {In the string s, replace all occurences of fs with ts.}
  s := ReplaceString(s,fs,ts);
end intrinsic;

intrinsic ReplaceString(~s::MonStgElt, fs::[MonStgElt], ts::[MonStgElt])
  {In the string s, replace all occurences of strings in fs with strings in ts.}
  for i:=1 to #fs do
    ReplaceString(~s,fs[i],ts[i]);
  end for;
end intrinsic;

// More code from Tim
intrinsic PrintRelExtElement(r::Any) -> Any
  {For storing character values as lists}
  K:=Parent(r);
  QQ:=Rationals();
  return K eq BaseRing(K)
    select QQ!r
    else   [PrintRelExtElement(u): u in Eltseq(r)];
end intrinsic;

intrinsic DelSpaces(s::MonStgElt) ->MonStgElt
{Delete spaces from a string s}
    chars := [x: x in Eltseq(Sprint(s)) | (x ne " ") and (x ne "\n")];
    if #chars eq 0 then
        return "";
    end if;
    return &cat(chars);
end intrinsic;

intrinsic PolredabsCache(f::Any, g::Any)
  { Write to a cache file of polredabs results }
  ff:= DelSpaces(Sprint(f));
  gg:= DelSpaces(Sprint(g));
  write(Sprintf("Polredabs/%o", Degree(f)), Sprintf("%o %o", ff, gg) : rewrite:=false);
end intrinsic;

intrinsic LoadPolredabsCache(n) -> Any
  {Load polredabs values of degree n from a file}
  prac:= AssociativeArray();
  try
    prastr:=Split(Read(Sprintf("Polredabs/%o", n)));
  catch e;
    return prac;
  end try;
  R<x>:=PolynomialRing(Rationals());
  for pdat in prastr do
    pralist:=Split(pdat, " ");
    prac[eval(pralist[1])] := eval(pralist[2]);
  end for;
  return prac;
end intrinsic;

intrinsic Polredabs(f::Any) -> Any
  {Have gp compute polredabs}
  // If degree is too large, we just return f, since we won't be adding this field to the LMFDB
  if Degree(f) gt 48 then
    return f;
  end if;
  vprint User1: "Calling polredabs on polynomial of degree", Degree(f);
  R<x>:=PolynomialRing(Rationals());
  out := Sprintf("/tmp/polredabs%o.out", Random(10^30));
  txt := Sprintf("/tmp/polredabs%o.txt", Random(10^30));
  //f:=R!f * Denominator(VectorContent(Coefficients(f)));
  // Avoid hardwiring gp path
  write(txt,Sprintf("polredabs(%o)",f): rewrite:=true);
  System("which sage>"*out);
  sagepath := DelSpaces(Read(out));
  System("rm " * out);
  if #sagepath gt 0 then
      System(sagepath*" -gp -f -q --default parisizemax=1G <"*txt*">"*out);
  else
      // Use gp directly instead
      System("which gp>"*out);
      gppath := DelSpaces(Read(out));
      System("rm " * out);
      System(gppath*" -f -q --default parisizemax=1G <"*txt*">"*out);
  end if;
  //try
  f:=eval DelSpaces(Read(out));
  //catch e;
  //end try;
  System("rm "* out);
  System("rm "* txt);
  return f;
end intrinsic;

intrinsic GAP_ID(G::Grp) -> Tup
{Use GAP to identify the group}
    vprint User1: "Using GAP to identify group of order", #G;
    out := Sprintf("/tmp/gap%o.out", Random(10^30));
    txt := Sprintf("/tmp/gap%o.txt", Random(10^30));
    if Category(G) eq GrpPC then
        desc := Sprintf("PcGroupCode(%o,%o)", SmallGroupEncoding(G), #G);
    elif Category(G) eq GrpPerm then
        desc := Sprintf("Group(%o)", Join([DelSpaces(Sprintf("%o", g)) : g in Generators(G)], ","));
    else
        error Sprintf("Category %o not yet supported", Category(G));
    end if;
    write(txt,Sprintf("IdGroup(%o);quit;", desc));
    System("which sage>"*out);
    sagepath := DelSpaces(Read(out));
    System("rm "*out);
    System(sagepath*" --gap -b -q <"*txt*">"*out);
    pair := eval DelSpaces(Read(out));
    System("rm "*out);
    System("rm "*txt);
    assert #pair eq 2;
    assert pair[1] eq #G;
    return <#G, pair[2]>;
end intrinsic;

intrinsic write(filename::MonStgElt,str::MonStgElt: console:=false, rewrite:=false)
  {Write str to file filename as a line
   rewrite:= true means we overwrite the file, default is to append to it
   console:= true means we echo the string as well.
   If the filename is the empty string, don't write it.}
  if console then str; end if;
  if filename ne "" then
    F:=Open(filename,rewrite select "w" else "a");
    WriteBytes(F,[StringToCode(c): c in Eltseq(Sprint(str)*"\n")]);
    Flush(F);
  end if;
end intrinsic;

intrinsic Classify (S::[], E::UserProgram) -> SeqEnum[SeqEnum]
{ Given a list of objects S and an equivalence relation E on them returns a list of equivalence classes (each of which is a list). }
    if #S eq 0 then return []; end if;
    if #S eq 1 then return [S]; end if;
    if #S eq 2 then return E(S[1],S[2]) select [S] else [[S[1]],[S[2]]]; end if;
    T:=[[S[1]]];
    for i:=2 to #S do
        s:=S[i]; sts:=true;
        for j:=#T to 1 by -1 do // check most recently added classes first in case adjacent objects in S are more likely to be equivalent (often true)
            if E(s,T[j][1]) then T[j] cat:= [s]; sts:=false; break; end if;
        end for;
        if sts then T:=Append(T,[s]); end if;
    end for;
    return T;
end intrinsic;

intrinsic IndexFibers(S::SeqEnum, f::UserProgram) -> Assoc
    {Given a list of objects S and a function f on S creates an associative array satisfying A[f(s)] = [t:t in S|f(t) eq f(s)]}
    A:=AssociativeArray();
    for x in S do
        y := f(x);
        if IsDefined(A, y) then
            Append(~A[y], x);
        else
            A[y] := [x];
        end if;
    end for;
    return A;
end intrinsic;

intrinsic CountFibers(S::SeqEnum, f::UserProgram : sort:=true) -> SeqEnum
{Given a list of objects S and a function f on S creates an list of pairs <y, m> where m is the number of s in S with f(s) = y.}
    A := IndexFibers(S, f);
    C := [<y, #vals> : y -> vals in A];
    if sort then
        Sort(~C);
    end if;
    return C;
end intrinsic;

intrinsic AssociativeArrayToMap(xs :: Assoc, codomain) -> Map
  {The map from Keys(xs) to codomain implied by xs.}
  return map<Keys(xs) -> codomain | k :-> xs[k]>;
end intrinsic;

/* convert number to cremona-type number */
intrinsic CremonaCode(num::RngIntElt : upper:=false) -> MonStgElt
{}
    q,r:=Quotrem(num,26);
    shift := upper select 65 else 97;
    strg:=CodeToString(r+shift);  /* a=97 z=122  A=65 Z=90 */

    x:=q;

    while x ne 0 do
        q,r := Quotrem(x,26);
        strg cat:= CodeToString(r+shift);
        x:=q;
    end while;
    return Reverse(strg);
end intrinsic;

intrinsic SplitLabel(label::MonStgElt) -> SeqEnum
{}
    function chartype(c)
        c := StringToCode(c);
        if 48 le c and c le 57 then return 0; end if;
        if 97 le c and c le 122 then return 1; end if;
        if 65 le c and c le 90 then return 2; end if;
        error "Invalid character type";
    end function;
    res := [];
    t := -1;
    for j in [1..#label] do
        if t eq -1 then
            i := j;
            t := chartype(label[i]);
        elif label[j] eq "." then
            Append(~res, label[i..j-1]);
            i := j+1;
            t := -1;
        else
            tt := chartype(label[j]);
            if tt ne t then
                Append(~res, label[i..j-1]);
                i := j;
                t := tt;
            end if;
        end if;
    end for;
    Append(~res, label[i..#label]);
    return res;
end intrinsic;

intrinsic CremonaUncode(code::MonStgElt) -> RngIntElt
{Also works on normal integers}
    digits := [StringToCode(c) : c in Eltseq(code)];
    if &and[48 le c and c le 57 : c in digits] then
        return StringToInteger(code);
    elif &and[97 le c and c le 122 : c in digits] then
        code := Join([CodeToString(c le 106 select c-49 else c-10) : c in digits], "");
    elif &and[65 le c and c le 90 : c in digits] then
        code := Join([CodeToString(c le 74 select c-17 else c-10) : c in digits], "");
    else
        error "Not a valid cremona code";
    end if;
    return StringToInteger(code, 26);
end intrinsic;

intrinsic SortLabels(labels::SeqEnum) -> SeqEnum
{Sort labels appropriately by splitting on "." and converting the pieces into integers}
    keys := [[CremonaUncode(c) : c in SplitLabel(label)] : label in labels];
    ParallelSort(~keys, ~labels);
    return labels;
end intrinsic;

intrinsic remove_whitespace(X::MonStgElt) -> MonStgElt
{ Strips spaces and carraige returns from string; much faster than StripWhiteSpace. }
    return Join(Split(Join(Split(X," "),""),"\n"),"");
end intrinsic;

intrinsic sprint(X::.) -> MonStgElt
{ Sprints object X with spaces and carraige returns stripped. }
    if Type(X) eq Assoc then return Join(Sort([ $$(k) cat "=" cat $$(X[k]) : k in Keys(X)]),":"); end if;
    return remove_whitespace(Sprintf("%o",X));
end intrinsic;

intrinsic strip(X::MonStgElt) -> MonStgElt
{ Removes whitespace from beginning and end of a string}
    i := 1;
    while X[i] in [" ", "\n", "\t"] do i +:= 1; end while;
    j := #X;
    while X[j] in [" ", "\n", "\t"] do j -:= 1; end while;
    return X[i..j];
end intrinsic;

intrinsic find_process_id(N::RngIntElt, i::RngIntElt : Nlower:=1) -> RngIntElt
{The overall index of a given group N.i among groups of all orders}
    return &+[NumberOfSmallGroups(m) : m in [Nlower..N-1]] + i;
end intrinsic;


// We encode groups using strings that allow for their reconstruction
// Moved from IO.m so that it could be used while just attaching hashspec

function is_iterative_description(desc)
    if "--" in desc then // using A--homdesc-->B format
        return false;
    end if;
    for i in [1..#desc - 1] do
        if desc[i] eq "-" and not desc[i+1] in "123456789" then
            return true;
        end if;
    end for;
    return false;
end function;

sporadic_codes := AssociativeArray();
perm_codes := AssociativeArray();
sporadic_codes["J1"] := "7,11Mat010000000100000001000000010000000100000001100000082AA8A89113133AA8A882A8A882A8A882AA13391133391131";
perm_codes["J1"] := "266Perm1259721111783453149730272509142179377049067743538198102645245277265470085277490453637158214982605104834758323517390226638817187456313613523999465197127362802209598267952014512510747540911803157557553818289071856278271373944770090100907115171307614461189857774563790185966615628082760041968064852513390924715338065593321357099315988219627000005969207427187157001630828373280747697783082570209606584639416945324054488581563836145878740103492272027879926185401379722411918817972160564438668098582416918969361498402617352632245921034407,701155812066915961378700966587079523609077512274991269102073834321031352600131920963565674297095969567308624271704131125807300960082598025889087581506068928466222858747448573936305158884255499909408112409707603162284793546835056732598012100396082675260028535036154246381767374970891107698283368396387215928236113038136918393064561399722127669715747414645784533635495147238123233432094240903490134277177181399907163048741457897863368712685834137356761509049017062687082857344757032951455838553434412132336096573112389003871098558302";
sporadic_codes["J2"] := "6,q4Mat111100000000101100000000101011110000011010110000001111110001111011001100011011101111011001101001010111111000000000001010111011110111111011011101";
perm_codes["J2"] := "100Perm73808052479830625725607724258745508048832990197035095711803317941956437123052644108850236776783936099424307891733825649946653784050618358644176244023835838004,77644347975527741426656522139282976057062013867475072084081390150476381017401701234365685903803382534505825183748511142569301008480903146046982874385524998139";
sporadic_codes["HS"] := "Simp138";
sporadic_codes["J3"] := "18,q9Mat201000000000000000000000000000000000000010000000000000000000000000000000202010000000000000000000000000000000000000001000000000000000000000000000000000000000100000000000000000000000000000000000001000000000000000000000000000100000000000000000000000000000000000000000000000001000000000000000000000000000000000000010000000000000000000000000000000000000100000000000000000000010000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000001000112120022120100222211111101000000200202102102201012202121021020010102200000000000000000010000000000000000000000000000000000000100000000000000000101102022111100102022110220000211210001000000000000000000000000000000000100000000000000000000000000000000000000000100000000000000000000000000000000010000000000000000000000000000000000000000010000000000000000000000000000000001000000000000000000000000000000000000000000010000000000000000000000000000000000000100000000000000000000000000000100000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000000000010000000122120102010010202011100102200000000000000000000000000001000000000000000000000000000000000000010000000000000000000000000000000000000000000000010201022112010002000102002001001011002000000000000000000000000000000100000";
// J3's smallest known permutation representation has degree 6156, so we omit it
sporadic_codes["McL"] := "Simp269";
sporadic_codes["He"] := "51,2Mat001000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000100100111011011000101011010000011001011111010000001000000000000000000000000000000000000000000000000000010001111111001010111010111010111011110010001001001100101001011110000110001011000101011001100111101100110100110101001000000001100101101101100000011101110110001010110011101011000110111100101110111111001000000010101110111000000010001111011011001011100010001000001101000001111011111111110101111101010010111110100000000000000000000000000000000000000000000000000001001100110111011100101000000111101001010010001001000010011111010010011111111111110110111011100011001100101001110111001100000011010011101101000000100011001111101101100000010101100011111010111011010101101011100000110110110010000100010000011010110010011011111010100000110011111010010100111111100011111110000101100101010010011111100110000101110101111111011100101011111110000100010110110100010001111010100010010110110110011000010101000001110000000011000100100000000100001011100001001111011011001100000110101111110011010000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000100000000000000000000000000000010101111001000111111001100010000010000111001000000000000000000000000000010000000000000000000000000000110111010010011110111001001010100010000100000010000000000000000000000000000000000000001000000000000000000000000000000000000000100000000000000000000000000000101101110101101001110011000110100010100000010000010000110011111010000011010000001110101111001000000000000000000000000000000001000000000000000000000000010000010101100100101000010101101010100100000010000000000000000000000000000000100000000000000000000000011110111000110010111101010111100110000011000101110110101101100111001111110110010010100100000010000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000100000000000000000000100000110011111000000000010001001010100111000001000101011011110100101001100101100100110100111101101010000111110110011100101110100100110100100001000010010001011101111000000110100101011101100000001101101111";
perm_codes["He"] := "2058Perm54356115520499308959461379592687807659076624677354377697593211692009622969877890694888628019524984062952388156123371571803761209233366287700029986470752354814515511664939911665984144532635891715048564353599842474937260066849877925589723167149186110788265155927890503961999787254789018017180461167772184793016241355294446371922500162750844098679548288260351680588209864613258884858907535325829160170193315596859689000108660801984283768066675361236128804714949278023954661766097500553239645158728680621111711213884212211194707247827353788467856479078212877090389069264258189353146779543040380334219692979145514467830318594452809500978053988659275027226470206898831681722526938485427401606767381417829919924093103930119756809889208936709420916872617058384087791274815518025985540865902024711315740324890664544343873472123887365472104447990724697698490980697587883643508599070904055240046306206502723760003225189306733500562397491399256197423403868671617655779201356291249793171415686741112400023443652493470720024730420498586625886130326257494364485075522308925164957130281430284088679669961766869292757782363756036587723569085295854074198037880441169507282403902536732009815002719130542742879178160526418608754164285387962348361812457824010534880223122414445456657575616269813008004880151907092024149975758963272804186505867868792105130976767551954378505027329211262421260239681409490404328147451404922737695586645916237048439294686080566672084678687608149397930321435948431954095835342500245948461318830686685055276232780814875225397587284174158728770651097051374365328470696837969464288523219400800701751259665711986917537522110827319875668669198452554337895888766995026456359189876372356909259272268291135506596316066216503324405105785647553444574948464184868319596172322856303313090184307422567382950721290476135132883091967729807094699918034681362439643342922745738880191925987327972926339703162806520117250822094252168173618260047071409329564495805045205940103648654998183659425296535676409768670500422506309938369134242494708582328650329976213004705353870171924747781699534947025945088495728608862686057665936508881973679501113729534643541258047406724663852740823933442746925799656303403652314041683208097843291534167362263703349144591673193104191155610532074707885066172538914314113357881123995309199039954429096046687093224096378087781438785845599804718303236037469908432213970145686698964878984174468800984184048356739750800745002596512248182978697003728192062498143986712730160153151119345519369530713720699001501781116802187556116869836060080138745762505620747827596389067508919931454740455350511621249591002991201908910092004569174809179993825114942714778605151825545343715437841217972197775300211492294908435133878684494894266676505695582309139197795964330437709571867613648898420151156444215138637014801413042386304540178281734779925941088346647319937201826218761717007055943658466857279361945553245560155694830732569258730993361846359587353389222061476092106710050004002492307058280631881590821869498587983049613478254705011176304275471013174344510166602425300165055639646011148016651169969578221632667441995517480205049328830272490149337074681818137603954663925931005837069320544766767893193676906235103449526585832450286694369831644170689454881005973666978202920993300075014893343803884508644193110293515999257177905328251334468188640019581538968624149232270541858409265356726197823686262004456245225376835061254312475211912396850378831231039940014086266875840656226568597261664633197871708414980366100704420152798427379298443881438805602460949523210197871002981484991626585312479642056379621210237294015437362360291972723187510587114262254133773990624770947492031259317534653012999345430574635962888077504679462421730913015937412477666431695376591581170476768776316277006359423180058681650273799939048376941936592537964869532891131653120538583011800720408644718052551561163810361998437376782650502418498084754101520455340321248469486216806784366910735158310038799000988007304138730516820045075394430233400284353744076245312456133077593338086278459555629576995521894421431352793226989172647905617515044746830890093059509226984650896423669916132641647422721368314290329093589858073991446331314399503042140222405435745442319771753686009475263852226862971313681429014000970989667155573241600332294287805794116198756760487582431814089054387987329462740877973700002214660234571499141123726108036607691851037820203013319411778437193863105454523107247629445646982528888972597619505334878755543880249986809784791141602743556035290886043249234511979281789953636086789591732553338909177437189354725747444788926170863939477701982071207521760677150017060209470842536679235190318102106854919265216624920309259834193572332875721492101090182692498009124186585771735060468839088963234138901225418314073479645328609442549254703590582699718830762353029430187898385764944594254424633302883733183439745467755600657633148840256772082876630735895310289738569799527398367397490221858655568932876061717955811377069161376154181020065262755312183542022190477466049174635542688483709708945184179837611430188845776733572719382626550678063516717560746449094348454302783187571292354732406744622903734613376290747968946091487409563098900665657575622993032380993407759814911774811314946844886467106030759418165222050748954368606340026999557283238191050452832489798009552682190355308655521140972134884912891947637405460430195960875711586890475197142481825653339317309437023088344639144251694724641155772782843793526776187000884823948268528680130970014700615061280299218003762544325843123398677388836492920437084081421485180996615880534636001765177941704304460247748252803376995533293228022510345717885178149297851116651915676448403600271583643537637314581214930700522856940273013423431802561059250145542010154215949276783090194873171723202386689678555052173655950797906142607313876153768163735879544487408664719186752979493179416119220702176655,40459642615769740779684120437984255245633084243163193362794510764751210206863530202555074498781857885369238835469158546885943804632387714658121664183997956743043761927683309982894759677627033570317723547473652482015126521785496344546671199754457341100816119483218641876156695987286823348847404032400616059622556149737539437093518031163358198471862995272377232320680599668256064386472892154987873530488424163959704043260318611076146696173773556081690904810176427730106022843832400455684030798959100818489031267431496202988959376916363476695960162444261741696532731669930251990370547656187467631956646437835289968558016210877270595903107075055469604599362524492418919700429050956779034855685688791167524508921174330753568799658605994894528293922383517859450312975576696399317889991892392102497984416096491847981243756094649653833864830083564008789605099656360635114816368066445026840599045458143650824669018267332090112140519963205086272365590247568039505732478808760077660510316861520702197735311675574173034682220917207598513172465310024309816645615088597083566126237025953390941012643734065708505795197621664188750054793837673476131336512845369736372356391394852706705267233332325409598170059441994916983279686699738464873441563082470793551092309795373711041634585696870077880697621156006786931858383228673339256980571418125773435708653439006006041405972925791451789047898210435741597234334043901855636136641737249892854782496863758969326341682631298517599491040415631596354257933492839907734574278854635127491331479208624029117300022334459571260728833184568587245753751650037936774392404530761947708360632809382341535087704760972836774810254945287917855760879376562617448001973327955481684570922962973616273374592229189398062830466316162186579614524410380420906758053292398657869411359818729200912130470660737546556612314213864604451375443068454615980866488847640073134169665215093717310588909030152432824905765121938825116369406667454836348472176307848500898342113809842227250304966844578557004187779365062796215832923355987001596882546402830723884762878225406922339027760646804344123486387901452294803200682905764445349042251469897725991415578301834300796455032471712079624777198710252852633418526559335559395839411003915975271938331242664842450995838023652372110516419145597489255898041686709792844652786371006202280293446359893197166748388466369438186734167766754413962797706503813953945452817536198331967304566601998301411060996243480388038032102776381528812162641837740056557303892441245950238638364617972642336861518319648751263352044160302946956490702342075213212180963610126043771439345524088518887408928812606954061460932242757650870158356652587989309636185929719212069696026353054237820891457151079027626887640480737162208544762895936320951391275947092808009397517958458035458786461425058194606506799433809914682398604586699169008504267803085255257790581931005500263359403843121599133903842258171947166831403227910250700586131851688469037028969087227315961045498783844383555362867245551850518450116913677599581736186521184431955677084580167858796765726355785397608365125210540435869002918170041180855730505023663936676395349426011249915338981834375734663426632201360957891437156013487202138214741481026114436965115375626102059351933333277127801678671233442829656483311733948066302821794713823825017763568608915982171813413934218592349725553790441256437972728791391515425911232090465417475275375429791455896177181562977648706773790541110090081222271696426496288917800479327774790447843776065571917921069325996974604351946136724586419633490241731168248578085128615742833752145353485884071528726204127213442594926937017804290009401452133092679065037424860889242960614328004232727732187394423706967285072863956791917227992190147136659768064892088116436283296602602599657374194639653315913697836909734788070280420216036441337209155751027850105242687951506077789021824035352064062715028692480744115745527902107776555614324255389959064201448183411002926633760998048503214972178590029765362947874585737460262471258461274944771330787330907789057381657955045379507102771753947604302280111319802280866191926099642844698803212719956948092711265648245330900216778626333676718656227833604052465779452919231422456512276141251890800290660418037757022350344047373949604188191758621234102021669701154973309082179725888493394524023529768354987039591282184853964541892068758540714244149033258775620175996725959867109769916172654002735886615237797604820593904535084069054369182974996125900699656610029866715838444912027788390046824279961892571249314215146809745348745721969889998959262221471663050099662752613004604940640685657565902790087482890109254631102139066577284847205920654685060644817817280753981208521849388738374775912626285745062403802111726294296497950307489878447887095016551153855340311559716541668350050944290065955448293759157067899017247557458210699802135075900801860339586498072180061363425450990298041680058361419880090707911774408293149024072132090517819956822804833181070196502385963763426148920525568050982566181273417576679337263939834898465203031888115340224139627954977753240192262349948314241075706505589601415966042770785266005236333708931683995183630518175193601570162244054324694156210943662166867581616151312233056956768584768144350685506924512561843933537233394924784456443266948248684592779493785289136808029863659348177559155085623088098389423702447389293143360138335317405158960513314415423327068223619689715213956875993829734878492850830989540788623926045442323608454038509228523041833245019602955427048639879372442443005492211615966269047855384034152963444695144370695883113247615646713476001101511593514178669947644983780979406442749810564128876041829179309239182087727529350498378553295844490131394526581878457061876483438440884664077271579690052244926374988092392475111035337717194917885361061993990466404314936633613979466900174134226870365022071224921609881465728010173299091637918194816153555";
sporadic_codes["Ru"] := "28,2Mat11000001100010000000100010100001100001000011100110001010101100000011100110111111010111100011011110000001000010101111011010101000001011001100110010011000111111100110010010000100000000111111100000111101010010000111110010101111000101101110010110100111111011111011110001011111011000000100000100101111100001010100011001001010001010011110101100110110010001110111001010101100110111111100110000111010110011001010101111011000000101100010101010111101011000100111010100111110011111000110001010110110010100011010010000001001001100011010010010001101100011000101001101111000101101000101001000111010111110000100111011110010011010100110010111010001101101100001001000110100111100001110000110011101111010011111010110100000101011101110001111001111100001000101010101000000111000011011101011110110111111101100110111110001010100100101010001101011011110101011000000010011110101001000110011000001010100101110111100110110100011000010000101111001001000000100100101001110011100011100011110000010100001100010100001001000001010010101100110000101111111000010110000110011001100110001011010010110000101011110001100110110100011100011011111101000100011111110110011111011000000011110100100111110001010001010010110011000101000100110000010111101101101110001100100101000011101111001101001100100010001010010100011000111000001100000001100000000101110100011000111101101011010111101011110000100111011110011101100001000111100110000000101000011100011110111110101011001001101100100010001110100001010011010111010110000111001111110010110111000011001011001000000110010100011010010101100010011011111110110000001101110";
// Ru's smallest known permutation representation has degree 4060, so we omit it
sporadic_codes["Co3"] := "22,2Mat10001001101001110110110010011000111110101011000100011100010110001000011111101110101011011010000011011011010100110000001000111111100110010011011011010010001110000000001000010001101000000001111001001110000010100011011110000110110111101010100001100111000011100101001101111100100101100000001010001010011100001000011010010010101101101101011101110101011001011101100110001000100110100010010011001000101110001000101000011010110100011010011011011100110010100010010111111001011001001000011000110101010100000001000001110110001000001010011011101000001100101001001100011100010110011000111010110111011111111011110110110001110010001100001110001111101101111010000111001010011011000001001111111011011011100011110000000100100000101001000011010010111100001100111101101111100011010010100100011111101111101101001110100110001110011100000001110010000011101000110010010101111010000100011101110000101110001111100110110100101001101110010001101101100100001000001111101001101110010100011100011100";
perm_codes["Co3"] := "276Perm2466345272311178886028414794609128542334377260506249689659059303546303797966087179039949658826791371417886956180529241654563836393954101495166360338119940637529465060754701449913788829107742629308292999796294622592276808834397754235859190555213224921804666312243280731547366888437266751261903767115730006854347818525185034796403551068934935058444124882536108261420907559721077426740956653320560417467205908151461152620079017498624300161352506814299582676258723328524695306579035965561903975756319492325020935646572761554969835310560446857556387470558989755,2058077711509619036839251890654141336850087932377173816117179949692578844821560852674535211738398733193691450899216638398083763281655273661907516143034312721500313053421030113519289694247943557168504666901110567177258645698083549949501076561339119715588123118778896760806369096275365240488310644776553371174586500106229870877740868493502812981867327026374835545935117268503605929642770233697717533699657652719074160855482622443315873589644712073748892914430429982374545456229989647333761341794072290133694295087194749988771396595907484957624235185533679021";
sporadic_codes["Co2"] := "22,2Mat01000000000000000000001000000000000000000000000100000000000000000000100000000000000000000000001000000000000000000000001000000000000000001000000000000000000000111110000000000000000001000000000000000011000100110000000000000000000000100000000000000010100001000000000000001110100010000000000000000000000000100000110010100000001000000000000000000000000001000000000000000100000000000010100000000101010000001010000001011011000000000000000001000000001101001000010010001011000100100001001000010010000000000000000000011000000000000000000000001000000000000000000000010000000000000000000000010000000000000000000000010000000000000000000000100000000000101010010000000000000000000000000100000000000000000000001000000000000000000000010000000000000000000000100000000000000000000001000000000000000000000001000000000000000000000010000001000000000000000000000000000000000000001000010110011011010100000001010011011011001000000111111100110101111000000000000000000000011111110111111111110110";
perm_codes["Co2"] := "2300Perm274990153959802819462138297535861607488841404303568511544035124904983218153875334658150777289589577149668005051302786211638582768972036351192376646177841474497756974812150636744088241916990017514494035056578791113908474307392313970321874586035334975583405961401952786856347216547642328988269243047339070719969308522512319406788450287602525823654695398645433444099262369015327476532370157644505381376534897560414085545679324160848001100516086655515296420211768202929019087653004831706643177094798297002741099591366300497801236421324007507356426238100727375932888297886972046008085885907274174089246879389197334777905246881449441142930186413916533865047572916207544433653776785346869764128031875652224092203150842186322703108140855977672949149498676263079460349580432019330101968527708460428204189060464422100093545309338684713202188886093084725471262205774494056876215194417956874194901346809945653049487283018349443208987068089249037318442202619646245077673300436433530528356403205834521179385025559665755783348846691176831093022298529621337433048908774719813831665578916920445458133680728542530990994796088562411674331902369375616921236526326503896953059916868714194332060733355546544102484881322500990834508634518860704435824303714429472368971332828728440212139197865326815310422450445477047630199522500080618530016693388690764123888882276000387992662090199780614080175432794070804341666543600734928106818922912548925543818555535257258643435730887327008889287338521620119874167700130819250173458097102831339162667476485333866075858176827244867562952012977281038272842215813939694299863608350149151062974815393240601829505824597140049448243763455355645651842523272078142683876243845507937246133708394312008821651661210446919182419356849608285745937804753293497529625804486679766002880166812533525344224723890971569381533580168794084921127622309993921905244273612552926046258499742596083707192625028115383972568183789331187524747708215306267319876043101314818165842101973049891029138230926050724121374836199671035784417911000651062313623519893966457355468035975073679415754414838866433878241940438125259076232257204720784513429819198216121238136245011157921665666363051116388165424650093151202372434896743430216454814870569038190980447454919732974979368795473916799383927650850395710422389222676357040770604394493667657572908155876238994559789589281036706829572324458547675249739946137760731341979607716982881109893137795435307449706624312073955853355364055110422381558806706002407195491870267688859387984925282793324476803735019877881735191373445281984409390759028315113834414253819181712120602514758587551964211185028049635550752831269311837256703278015237706549039296741878081242393515727198708782179144787578989456538190412851082160885886318941215449866887164566615156699284826567701258054760603291922276899849890920919161945593767138151112736947273181747695070091482046858628757206619693455549156421546779556250404953902740388582988336355049693150129770764206949729867809525795399995583187531886161167978822784285101404625798643622374022708370199932403059063336366215632728592301160795140682633909320129647776260476560715420209090078911588545267621541646527330047922672741657932677510161328508910045048052697370428904377398816818120486904771813882996235482171840832181807015636047661222385927717471748266962860008547664436460647729483961514921480536449817652277687872551145149663942718595885692421252182443744299303222156998181504525927902729976396519426149670815067876354879633001483838354848611959904753900384850538022116810266813951425604987222363497278731537742679161263042396023130020714388581934929586372940573584551582766580585600492025817254725786039367704544748500385201847472244525137960887816764459279339196404004037206689011929334998456602227196883125389357077840688384570144840713249496572070491476703142789352039866545428645436272981533285064430574995535437037012224912119193902046091621241641614753847966885239926074428286716427183991043118066138462205123158551077099342592450547992267464132954881615215251036511035577152455835200825876452859097189786161345886190520130901142929677627913156326856497008037391534754484120128728827889823986043442773177058236326627022735799039534574983190440270930137822495462551692403643428231816069724430563754765086994252700010407939367188551169134225450128310413416111521579802476294810801663757596674646541808140724310518839222696377947156866528653120107568796456874190147909798459294696340822764090408928073649272715821666598261828816480609706720246285234562546368746194141262418306591124624823619613250954112825121884188971460230295401834366426718243989648095810240771616075850877807547881636008705445955992807773753249798438577936962901434265845722216693714319017743977777031909749776410250689080575082692614386414799481821050789713078990151856721478186946101573074785114134841301163523023492856917187966092009310138977731689436120151015431277034249681030861400601594890258786964738182208088826296089453590963193901280113620668156313598460553858355447742484647699829166002362937347848507495169346215899032895960086189160866428614079476913964449082151347203286177750012872791633296753025188060021781735313726164909784230311638137258202763508698082416077203722545326655488186566640016798380735310426203759160778269931889307198544788408690629723961491000258583085017673657335024680574917759620060095789290321784026710550557955723945274430466274105356580428481152884013728204885996059904203005439363329751261703368955108367174985229291055767512082272544303550425260405445044438645944375977534681465873031964691118318196855744437442191543409788430757095041784606197985343921838107781980540568823031121966619365551826142193547783328519265441102968887724638618580200793060411476901911237804170759973850713740535145012788089363203214845805078001115843240646832425924339745531071441564221572900673347077569305673341762016095919924927241080436607117454600782119165927774375220268923294614761245326866929232511203164595552029605723518482298203414175011718009494617450513124213980327572964527917698222702666722412912796036239370369807538215581446435607109894607776185494831429570426769049752301474048717189184945074785999281548353775112225361913052854250675267664601041829872883073693491539146383864290687041589618059263944356772370564178661318733484129407686182208835000622011239123964961634804719553461723868786849630254041488269878724006173082327549756277923815323305738002654778143956520388575516340416430258517018846193797145146627064539294504257767353090020996993020906029611076308802936691705977498739785959136218821514449062237566984050993842972526601245386323487985402833917432078227800326827869251067571955356460068823921379932079906776492623076850434208877335097158862038907546,924187149994164559932948211380255148495368849480232901981318494853281013357358004391646664789087861976942687512978046508888829925864332226748586415555019709849338598324286952521956651540644951096402480295906299296316146346719897223580809715256163874759129812954671066017544597681877175995130318791218755708878335054544654660633590906287526140837233998747692936248128389359868005236844944412269254171841606417034624158911559308512600667109420823122000972002496050368931237593938999291585948501481536240464253601241128158807587718689253544282018569373477568791045900750589934848792322593546276689937426314699812373616810917518070352695351391455533879268406574490173455087344929096788458124083675713748982337479711089847685083040340769593192835048294483910581535030109843895718390004978027728226311957180583948479910204498168082130738555637981396418069668737631211377191134022275266066663215514824026728126642415109695705750640809586761574414843805950143016909947047787578562648745271259314968158054229187034362268551563356791255989814904176938869560787011529923551597137343689377614242199900239952584385529885844854112300881197399581170882757688245039796431601035936214037466058904294066604552134512102357045130205788182431807033169372389139941035408601525555850499243583295699585770102683547884164115613708285489049501521144483559986282119816899272602671189470967496029426728440232605177428396987444781713085104155400439383233990002658058174549782263865676037875363458278693391877485871180055442060163732878149526239005565767306127028382924281079106025631896033647870722323520462756595905456570639898332085337963064249578124782241873653712545847700334838650475303929080084297665944552976815297390106716777217434780864334615848684577001647840548954107849380468182590655802483675777917611283526114329671624182019193702367483164643884970913015902138274789292025015685230331200261855697395387046255557271911191554782630599577427845991285208362964978134875207775998049480290942440690475027825364723686564335384214903598011101572069567142023296057368563685399338231572891931479160281157556014641155420775390853031326160702833162728070492137094835634236797723436429236332697601173644325996789514015349887197086955440205078281399981389312653982480560146117846452844655033809548465917338940657220710810989473257859983964262181419902829291691117884492749895087819397493695610736137063675386373866689000551412701756602854528360159704150421290756179590121871887160195033152820767310747646569819867625745134489996119880127655918647315551852626234451503480480386102405160962980874214517669444204322330900498565628393742854813666751457012952668357677404605407025389312981074729234249947510534042914178456519041694492812623540915792761606406785006327231742880641080980196141998670937370300521990704775684240475708817987350748667586116924303549791271882844292638381440645876597750311111749733482105602142157700673222654908630789145986175551082225254530462470398763277951836423808121010927721899111967550444455450345707439030596218677336699289911554927123635910443325550596725939301444479803881004843513546372963323659203266510123701652635568550683132273078227959027964125483052539919531024286870546844648866394265129521034086139183609987958006522760412655012471663913943472095591098312987338166351719695384244889016624657475624436065576217374262316327744781369415125126999401020432959227835984150396520191895088009630361784733136094622581309975823833899622005605766133885184010421658415804924534756176942076067668089540519116293665206441187736424685157979717146160723041762933865512260779055192389184453541111990507655327059148778723420576062601126999969070107660857704972425150015739933488235031562962856145900620251428246712195509102229266990416786924336869113488536405946330283231315239425902638494360938424956679286520726651191269771590413741368715704378839544658352868229867766656964987856660955451242894501646146112236861457843389674316113542301900784259622945109380072855906826077313815588859723558596304720830751580017267248725121153829150095206150094271318919057476491340530859582440680850552383462683274853253182505814676547914248538237100347792851310198258621966639507323637830436589032952353897866986656559535664821048883386468767493533058979928404166639614696461739933641990166958239285132087234504087304550971811181881503061758612237795504332335301556751867654903829192197337656615081040832954856093028350816323448506816509661451858082287970272832527552784403459214926060787608745234365689989462747109587170289835938279311529659153117162320239522081336741900211170518392549585582677755709234211328688415737429002420045437072858409866766831678327561366235884052057262137739260783508091707127637061374870639623873174024385167338163199061907780768145895933982475539883907042879717540882486506803748892022966440483973664131254360491285654924267285629219967035224199918906778101807405177342515707905533842641159872211468646725626765609169218836276678891187103035450927143265007081577251924175510407879688133848160306449487860059334766367517254166555220865637341937155522078877462930119256406232645184029956013809865579827442416335625798967487642748089047329862777634302392989641467537453738510204061965649374269327031902285243311651082462079028494803251768602308664767837896076003020996152888393002286950821904588594872972988881331777010415530746409760121143577616411876531163681075376784274983277197044202693147862087570613335707165114827216254960479654955757215269724284799539863729130962046458551280595358529282375397982010990121391910993344041197210605575504468706529289143542626990062934759881722829343045596605257268451038857129654384503645465255128646166134168340025364754139535732812136866133867901966893016785381746112998370514707191538106048633190622174693891352404343731601607316980187469811191208785355636071804807019472478200810549321554996020165927041345003962705669588262603226860731903574381523993317733706085332384753262517076686341759632639519238165363912419100855411238641985859211463964915987642130187000014557848219406775526187425928980173995987341051833049812155788351140391734001601151649529711280766484617395273907384892451884304297614639993716483731227095231011461509529028470017974375622649904650530315067265897670346545297483196530913810599401386672032249149689736327028282681527163926700363343089396997032909145522747656496736921496841613585322977635699904621851418242988117768346497249217696666214695518611608221724279757442619086308820514254340129621833212884969105810172082091645408909011252975798132308763376229874880084472768795484298654127008110874995599783828251916758220064773315117674923612015443592104772621380893780703638200690494740835505091321647677175923875832038222903227035811165924793466052244699315";
sporadic_codes["Co1"] := "24,2Mat111101000111000010000110110110010011011100000111000101100001000000101101111110010110010010000110110000100010010111001110100100101010001001100011001011001101011010011111000110011001110111010111000011100110110111110110001011110010011110010100001000000101010001101001110110000101001111001000001000110000100001000110101011011000110001010100010110011111100111011101110111100001001101000010101101100110011110000011111100000110011101001010110100111010000010000111101100101101010000111111010010101010000001000100011100100100001110010100100110101100010110101000101001000010101000100011011001001011001001111011010010011110110010100001010111101000000010101111110001101110100101110100010101101100110001110110101111010000001000001101101110001011101001111010001010000011101010000001010100111100000101110101110000000100010111111001101001011001101001010110101001111110110010101011110001100111010000101000100101111011101111010111100101110110001000101000110111110100000111010011000111100010000111011001100010011110100111101100010010101110011101010111000010110000001010010001001101111000000100101001110111111100000110100110010101110011101101011101010001000000110111111101";
// Co1's smallest known permutation representation has degree 98280, so we omit it

function HexToInteger(s)
    return StringToInteger(s, 16);
end function;
function HexToSignedInteger(s)
    if HexToInteger(s[1]) gt 7 then
        return HexToInteger(s) - 16^#s;
    else
        return HexToInteger(s);
    end if;
end function;

function IntegerToHex(n, b)
    n := Integers()!n;
    if n lt 0 then
        n +:= 16^b;
    end if;
    assert n lt 16^b;
    s := Sprintf("%h", n);
    s := s[3..#s]; // strip leading 0x
    return "0"^(b-#s) * s;
end function;

intrinsic SplitMatrixCodes(L::MonStgElt, d::RngIntElt, Rcode::MonStgElt) -> SeqEnum, Rng
{Given a string L representing a list of matrices via MatricesToHexList, returns a list of lists of integers giving the corresponding matrices together with the base ring}
    b := 1;
    if Rcode eq "0" then
        R := Integers();
        // b := #L div d^2; // This doesn't work, since we can't distinguish between 2 generators with b=1 and 1 generator with b=2.
        b := 1; // This won't always hold, but all matrix groups added so far have entries in -1,0,1.
    elif Rcode[1] eq "q" then
        q := StringToInteger(Rcode[2..#Rcode]);
        _, p := IsPrimePower(q);
        b := 1 + Ilog(16, p-1);
        R := GF(q);
    else
        N := StringToInteger(Rcode);
        b := 1 + Ilog(16, N-1);
        R := Integers(N);
    end if;
    if "," in L then
        L := [StringToInteger(c) : c in Split(L, ",")];
    else
        assert IsDivisibleBy(#L, d^2);
        if Rcode eq "0" then
            L := [HexToSignedInteger(L[i..i+b-1]) : i in [1..#L by b]];
        else
            L := [HexToInteger(L[i..i+b-1]) : i in [1..#L by b]];
        end if;
    end if;
    assert IsDivisibleBy(#L, d^2);
    if Rcode[1] eq "q" then
        k := Degree(R);
        L := [R!L[i..i+k-1] : i in [1..#L by k]];
    end if;
    return [L[i..i+d^2-1] : i in [1..#L by d^2]], R;
end intrinsic;

intrinsic SplitMATRIXCodes(L::MonStgElt, d::RngIntElt, Rcode::MonStgElt, b::MonStgElt) -> SeqEnum, Rng
{}
    if Rcode eq "0" then
        R := Integers();
        b := StringToInteger(b);
        shift := (b - 1) div 2;
    elif Rcode[1] eq "q" then
        q := StringToInteger(Rcode[2..#Rcode]);
        _, p := IsPrimePower(q);
        b := p;
        R := GF(q);
    else
        N := StringToInteger(Rcode);
        b := N;
        R := Integers(N);
    end if;
    L := [StringToInteger(c) : c in Split(L, ",")];
    L := [IntegerToSequence(mat, b) : mat in L];
    function Pad(X, m)
        return #X ge m select X else X cat [0 : i in [1..m-#X]];
    end function;
    if Rcode[1] eq "q" then
        k := Degree(R);
        L := [Pad(mat, k*d^2) : mat in L];
        L := [[R!mat[i..i+k-1] : i in [1..#mat by k]] : mat in L];
    elif Rcode eq "0" then
        L := [[c - shift : c in Pad(mat, d^2)] : mat in L];
    else
        L := [Pad(mat, d^2) : mat in L];
    end if;
    return L, R;
end intrinsic;

function dbcFromdR(dR)
    dR := Split(dR, ",");
    if dR[2] eq "0" then
        d, Rcode, b := Explode(dR);
    else
        d, Rcode := Explode(dR);
        b := "";
    end if;
    d := StringToInteger(d);
    return d, b, Rcode;
end function;

intrinsic StringToGroup(s::MonStgElt : baseG:=0) -> Grp
{}
    // We want to support iterated constructions separated by hyphens, but also need to handle negative signs
    s := strip(s);
    if is_iterative_description(s) then
        path := Split(s, "-");
        if baseG cmpeq 0 then
            G := StringToGroup(path[1]);
        else
            // We need to be able to specify an existing group for PC groups rather than creating a new one.
            G := baseG;
        end if;
        for zig in path[2..#path] do
            if zig[1] eq "A" then
                // Since computing the automorphism group can be expensive, we allow storage of the actual automorphisms
                if #zig eq 1 then
                    G := AutomorphismGroup(G);
                else
                    gens, auts := Explode(Split(zig[2..#zig], ";"));
                    gens := [LoadElt(c, G) : c in Split(gens, ",")];
                    auts := Split(auts, ",");
                    auts := [auts[i..i+#gens-1] : i in [1..#auts by #gens]];
                    auts := [[LoadElt(c, G) : c in phi] : phi in auts];
                    G := AutomorphismGroup(G, gens, auts);
                end if;
            elif zig eq "Z" then
                G := Center(G);
            elif zig eq "D" then
                G := DerivedSubgroup(G);
            elif zig eq "P" then
                G := FrattiniSubgroup(G);
            elif zig eq "F" then
                G := FittingSubgroup(G);
            elif zig eq "R" then
                G := Radical(G);
            elif zig eq "S" then
                G := Socle(G);
            else
                // may want to add quotients here
                error "Unrecognized group construction term", zig;
            end if;
        end for;
        return G;
    elif "Simp" in s then
        N := StringToInteger(s[5..#s]);
        return SimpleGroup(N);
    elif "Perf" in s then
        N := StringToInteger(s[5..#s]);
        return PermutationGroup(PerfectGroupDatabase(), N);
    elif "Chev" in s then
        series, n, q := Explode(Split(s[5..#s], ","));
        n := StringToInteger(n);
        q := StringToInteger(q);
        return ChevalleyGroup(series, n, q);
    elif "Mat" in s then
        dR, L := Explode(PySplit(s, "Mat"));
        d, Rcode := Explode(Split(dR, ","));
        d := StringToInteger(d);
        L, R := SplitMatrixCodes(L, d, Rcode);
        return MatrixGroup<d, R| L >;
    elif "MAT" in s then // encode matrices as integers rather than hex strings
        dR, L := Explode(PySplit(s, "MAT"));
        d, b, Rcode := dbcFromdR(dR);
        L, R := SplitMATRIXCodes(L, d, Rcode, b);
        return MatrixGroup<d, R| L >;
    elif "Perm" in s then
        n, L := Explode(PySplit(s, "Perm"));
        n := StringToInteger(n);
        L := [DecodePerm(StringToInteger(c), n) : c in Split(L, ",")];
        return PermutationGroup<n | L>;
    elif "PC" in s then
        N, code := Explode([StringToInteger(c) : c in PySplit(s, "PC")]);
        return SmallGroupDecoding(code, N);
    elif "pc" in s then
        N, compact := Explode(PySplit(s, "pc"));
        compact := [StringToInteger(c) : c in Split(compact, ",")];
        return PCGroup(compact);
    elif s[#s] eq ")" and #Split(s, "(") eq 2 then
        // We just use the Magma command to store classical matrix groups, since we can then recover
        // the homomorphism in the projective case
        // We don't just eval in case this code is ever used with untrusted input
        cmd, data := Explode(Split(s[1..#s-1], "("));
        n, q := Explode([StringToInteger(c) : c in Split(data, ",")]);
        assert cmd in ["GL", "SL", "Sp", "SO", "SOPlus", "SOMinus", "SU", "GO", "GOPlus", "GOMinus", "GU", "CSp", "CSO", "CSOPlus", "CSOMinus", "CSU", "CO", "COPlus", "COMinus", "CU", "Omega", "OmegaPlus", "OmegaMinus", "Spin", "SpinPlus", "SpinMinus", "PGL", "PSL", "PSp", "PSO", "PSOPlus", "PSOMinus", "PSU", "PGO", "PGOPlus", "PGOMinus", "PGU", "POmega", "POmegaPlus", "POmegaMinus", "PGammaL", "PSigmaL", "PSigmaSp", "PGammaU", "AGL", "ASL", "ASp", "AGammaL", "ASigmaL", "ASigmaSp"];
        CMD := eval cmd;
        if cmd in ["AGL", "ASL"] then // wish we could do "ASp", "AGammaL", "ASigmaL", "ASigmaSp"
            return CMD(GrpMat, n, q);
        else
            return CMD(n, q);
        end if;
    elif s in ["J1", "J2", "HS", "J3", "McL", "He", "Ru", "Co3", "Co2", "Co1"] then
        return StringToGroup(sporadic_codes[s]);
    elif "." in s then
        N, i := Explode([StringToInteger(c) : c in Split(s, ".")]);
        return SmallGroup(N, i);
    elif "T" in s then
        n, t := Explode([StringToInteger(c) : c in Split(s, "T")]);
        return TransitiveGroup(n, t);
    else
        error "Unrecognized format", s;
    end if;
end intrinsic;

intrinsic StringIsPermGroup(s::MonStgElt) -> BoolElt
{}
    if "-A" in s then
        return Type(StringToGroup(s)) eq GrpPerm;
    elif "Perm" in s or "Perf" in s or "T" in s then
        return true;
    elif "Mat" in s or "Chev" in s or "PC" in s then
        return false;
    else
        return Type(StringToGroup(s)) eq GrpPerm;
    end if;
end intrinsic;

intrinsic MatGroupToPermGroup(G0::GrpMat) -> GrpPerm, Map
{}
    V := RSpace(G0);
    x := Random(V);
    T := {x};
    psi, G, K := OrbitAction(G0, T);
    while #K ne 1 do
        x := Random(V);
        Include(~T, x);
        psi, G, K := OrbitAction(G0, T);
    end while;
    // Another option: use MyQuotient
    G2, psi2 := MyQuotient(G0, sub<G0|>);
    if Degree(G2) lt Degree(G) then
        return G2, psi2;
    else
        return G, psi;
    end if;
end intrinsic;

intrinsic PCGroupToPermGroup(G::Grp : num_starts:=60, num_steps:=60) -> GrpPerm, Map
{Randomly searchest for corefree subgroups to get a transitive permutation representation of G0.
 Increasing num_starts and num_steps will increase the runtime linearly and may give a lower degree representation.}
    best := sub<G|>;
    for i in [1..num_starts] do
        H := sub<G|>;
        for j in [1..num_steps] do
            g := Random(G);
            if g in H then
                continue;
            end if;
            K := sub<G|H,g>;
            if #Core(G, K) eq 1 then
                H := K;
            end if;
        end for;
        if #H gt #best then
            best := H;
        end if;
    end for;
    rho := CosetAction(G, H);
    return Image(rho), rho;
end intrinsic;

intrinsic StringToPermGroup(s::MonStgElt) -> GrpPerm
{}
    if s in ["J1", "J2", "He", "Co3", "Co2"] then
        return StringToGroup(perm_codes[s]);
    end if;
    G := StringToGroup(s);
    if Type(G) eq GrpPerm then
        return G;
    elif IsAbelian(G) then
        invs := AbelianInvariants(G);
        return PermutationGroup(AbelianGroup(invs));
    elif Type(G) eq GrpMat then
        return MatGroupToPermGroup(G);
    elif Type(G) eq GrpAuto then
        return PermutationGroup(G);
    elif Type(G) eq GrpPC then
        // In practice for us, these groups are fairly small (but failed on MinimalDegreePermutationRepresentation), so we just aim to find a transitive permutation representation randomly
        return PCGroupToPermGroup(G);
    end if;
end intrinsic;

intrinsic CoefficientRingCode(R::Rng) -> MonStgElt
{}
    if Type(R) eq RngInt then
        return "0";
    elif Type(R) eq RngIntRes then
        return Sprint(Modulus(R));
    elif Type(R) eq FldFin then
        p := Characteristic(R);
        k := Degree(R);
        if k eq 1 then
            return Sprint(#R);
        elif DefiningPolynomial(R) ne ConwayPolynomial(p, k) then
            error "Matrix rings over finite fields not defined by a Conway polynomial are unsupported";
        else
            return Sprintf("q%o", #R);
        end if;
    else
        error "Unsupported coefficient ring", R;
    end if;
end intrinsic;

intrinsic MatricesToHexlist(L::SeqEnum, R::Rng) -> SeqEnum, MonStgElt
{}
    L := &cat[Eltseq(g) : g in L];
    if Type(R) eq RngInt then
        b := Max([1 + Ilog(16, Integers()!(2*Abs(c+1/2))) : c in L]); // only need 1 digit for -8, but 2 for 8; deals with c=0 correctly
    elif Type(R) eq RngIntRes then
        b := 1 + Ilog(16, Modulus(R) - 1);
    elif Type(R) eq FldFin then
        p := Characteristic(R);
        b := 1 + Ilog(16, p-1);
        if Degree(R) gt 1 then
            L := &cat[Eltseq(a) : a in L];
        end if;
    end if;
    return [IntegerToHex(c, b) : c in L], CoefficientRingCode(R);
end intrinsic;

intrinsic MatricesToIntegers(L::SeqEnum, R::Rng) -> SeqEnum, MonStgElt
{}
    L := [Eltseq(g) : g in L];
    Rcode := CoefficientRingCode(R);
    if Type(R) eq RngInt then
        Lcat := &cat(L);
        m := Min(Lcat);
        M := Max(Lcat);
        if Abs(M) gt Abs(m) then
            b := 2*Abs(M);
        else
            b := 2*Abs(m) + 1;
        end if;
        // b = 2 supports 0,1; b=3 supports -1,0,1; b=4 supports -1,0,1,2
        shift := (b - 1) div 2;
        L := [[c + shift : c in mat] : mat in L];
        Rcode *:= Sprintf(",%o", b);
    else
        b := Characteristic(R);
        if Type(R) eq FldFin and Degree(R) gt 1 then
            L := [&cat[Eltseq(a) : a in mat] : mat in L];
        end if;
        L := [[Integers()!a : a in mat] : mat in L];
    end if;
    return [SequenceToInteger(mat, b) : mat in L], Rcode;
end intrinsic;

intrinsic GroupToString(G::Grp : use_id:=true) -> MonStgElt
{}
    // This produces a string from which the group can be reconstructed, up to isomorphism
    // Note that it does not guarantee the same presentation or choice of generators
    N := use_id select #G else 0;
    if Type(G) eq GrpAuto then
        A := G;
        G := Group(G);
        Gdesc := GroupToString(G);
        if Type(G) eq GrpPC then
            gens := PCGenerators(G);
        else
            gens := Generators(G);
        end if;
        auts := &cat[[phi(g) : g in gens] : phi in Generators(A)];
        gens := [SaveElt(g) : g in gens];
        auts := [SaveElt(gimg) : gimg in auts];
        return Sprintf("%o-A%o;%o", Gdesc, Join([Sprint(g) : g in gens], ","), Join([Sprint(a) : a in auts], ","));
    elif use_id and CanIdentifyGroup(N) then
        return Sprintf("%o.%o", N, IdentifyGroup(G)[2]);
    elif Type(G) eq GrpPerm then
        if use_id and IsTransitive(G) and Degree(G) lt 48 then
            t,n := TransitiveGroupIdentification(G);
            return Sprintf("%oT%o", n, t);
        else
            return Sprintf("%oPerm%o", Degree(G), Join([Sprint(EncodePerm(g)) : g in Generators(G)], ","));
        end if;
    elif Type(G) eq GrpMat then
        // L, R := MatricesToHexlist([g : g in Generators(G)], CoefficientRing(G));
        // return Sprintf("%o,%oMat%o", Dimension(G), R, &*[Sprint(c) : c in L]);
        L, R := MatricesToIntegers([g : g in Generators(G)], CoefficientRing(G));
        return Sprintf("%o,%oMAT%o", Dimension(G), R, Join([Sprint(c) : c in L], ","));
    else
        if Type(G) eq GrpAb then
            G := PCGroup(G);
        end if;
        if Type(G) eq GrpPC then
            // Unfortunately, there's a bug in SmallGroupDecoding, so we prefer to use CompactPresentation
            // code, N := SmallGroupEncoding(G);
            // return Sprintf("%oPC%o", N, code);
            pres := CompactPresentation(G);
            return Sprintf("%opc%o", #G, Join([Sprint(c) : c in pres], ","));
        end if;
        error Sprintf("Unsupported group type %o of order %o", Type(G), N);
    end if;
end intrinsic;

intrinsic SubgroupToString(G::Grp, H::Grp) -> MonStgElt
{}
    // H should be a subgroup of G
    if Type(G) eq GrpAuto then
        // Stripping out the ambient group description would require a lot of code duplication in decoding
        return GroupToString(H);
    elif Type(G) eq GrpPerm then
        return Join([Sprint(EncodePerm(g)) : g in Generators(H)], ",");
    elif Type(G) eq GrpMat then
        if #H eq 1 then
            return "";
        end if;
        return &*MatricesToHexlist([g : g in Generators(H)], CoefficientRing(H));
    elif Type(G) eq GrpPC then
        b := 1 + Ilog(16, Max(PCPrimes(G)));
        if #H eq 1 then
            return "";
        else
            return &*[IntegerToHex(c, b) : c in Eltseq(G!g), g in PCGenerators(H)];
        end if;
    else
        error Sprintf("Unsupported subgroup type %o of order %o", Type(H), #H);
    end if;
end intrinsic;

intrinsic StringToGroupHom(s::MonStgElt) -> Map, BoolElt
{Returns the map described, together with a boolean describing whether elements should be lifted from the codomain to the domain (indicated by a >> arrowhead) or mapped from the domain to the codomain (true in first case, false in second)}
    if "--" in s then
        // Describe the homomorphism explicitly
        pieces := PySplit(s, "--");
        if #pieces ne 3 then
            error "Invalid hom string with", #pieces-1, "-- segments";
        end if;
        G, f, HH := Explode(pieces);
        assert #HH gt 1 and HH[1] eq ">";
        if HH[2] eq ">" then
            cover := true;
            HH := HH[3..#HH];
        else
            cover := false;
            HH := HH[2..#HH];
        end if;
        G := StringToGroup(G);
        H := StringToGroup(HH);
        if Type(H) eq GrpMat then
            if "MAT" in HH then
                dR, L := Explode(PySplit(HH, "MAT"));
                d, b, Rcode := dbcFromdR(dR);
            elif "Mat" in HH then
                dR, L := Explode(PySplit(HH, "Mat"));
                d, b, Rcode := dbcFromdR(dR);
            else
                assert IsFinite(CoefficientRing(H));
                d := Degree(H);
                b := "";
            end if;
            f := SplitMATRIXCodes(f, d, Rcode, b);
        else
            f := Split(f, ",");
            f := [LoadElt(m, H) : m in f];
        end if;
        Ggens := [g : g in Generators(G)];
        assert #Ggens eq #f;
        return hom<G -> H | [Ggens[i] -> f[i] : i in [1..#Ggens]]>, cover;
    elif s[#s] eq ")" and #Split(s, "(") eq 2 and Split(s, "(")[1] in ["PGL", "PSL", "PSp", "PSO", "PSOPlus", "PSOMinus", "PSU", "PGO", "PGOPlus", "PGOMinus", "PGU", "POmega", "POmegaPlus", "POmegaMinus", "PGammaL", "PSigmaL", "PSigmaSp", "PGammaU"] then
        cmd, data := Explode(Split(s[1..#s-1], "("));
        n, q := Explode([StringToInteger(c) : c in Split(data, ",")]);
        if "amma" in cmd or "igma" in cmd then
            up := cmd[2] * cmd[#cmd]; // GL, SL, Sp or GU
        else
            up := cmd[2..#cmd];
        end if;
        up := eval up;
        cmd := eval cmd;
        G := up(n, q);
        P, S := cmd(n, q);
        nonzero := [Min([i : i in [1..Degree(v)] | v[i] ne 0]) : v in S];
        function Slook(v)
            for i in [1..#S] do
                if v eq S[i] * v[nonzero[i]] / S[i][nonzero[i]] then
                    return i;
                end if;
            end for;
        end function;
        f := hom<G -> P | [g -> P![Slook(v * g) : v in S] : g in Generators(G)]>;
        return f, true;
    else
        // The identity homomorphism on a single group
        G := StringToGroup(s);
        return IdentityHomomorphism(G), false;
    end if;
end intrinsic;

intrinsic GroupHomToString(f::Map : cover:=false, GG:="", HH:="") -> MonStgElt
{}
    G := Domain(f);
    H := Codomain(f);
    if G cmpeq H and &and[f(g) eq g : g in Generators(G)] then
        return GroupToString(G : use_id:=false);
    end if;
    if #GG eq 0 then
        GG := GroupToString(G : use_id:=false);
    end if;
    if #HH eq 0 then
        HH := GroupToString(H : use_id:=false);
    end if;
    arrowhead := cover select ">>" else ">";
    if Type(H) eq GrpMat then
        L, R := MatricesToIntegers([f(g) : g in Generators(G)], CoefficientRing(H));
        fdef := Join([Sprint(c) : c in L], ",");
    else
        fdef := Join([SaveElt(f(x)) : x in Generators(G)], ",");
    end if;
    return GG * "--" * fdef * "--" * arrowhead * HH;
end intrinsic;

// Computing the hom for projective groups like PGL can get slow, so we save them
intrinsic PStringToHomString(s::MonStgElt) -> MonStgElt
{}
    f := StringToGroupHom(s);
    desc := PySplit(GroupHomToString(f), "--")[2];
    cmd, data := Explode(Split(s[1..#s-1], "("));
    n, q := Explode([StringToInteger(c) : c in Split(data, ",")]);
    if "amma" in cmd or "igma" in cmd then
        up := cmd[2] * cmd[#cmd]; // GL, SL, Sp or GU
    else
        up := cmd[2..#cmd];
    end if;
    return Sprintf("%o(%o,%o)--%o-->>%o", up, n, q, desc, s);
end intrinsic;

/*
intrinsic StringToSubgroup(G::Grp, s::MontStgElt) -> Grp
{}
    if Type(G) eq GrpAuto then
        return GroupToString(s);
    elif Type(G) eq GrpPerm then
        n := Degree(G);
        L := [DecodePerm(StringToInteger(c), n) : c in Split(s, ",")];
        return sub<G|L>;
    elif Type(G) eq GrpMat then
        
*/

intrinsic ConjClassTupAction(A::GrpAuto : n:=1, dbound:=5000, try_union:=false) -> Grp
{G, a permutation group; reps, a list of elements of G in DISTINCT conjugacy classes}
    dmin := 1;
    dprod := 1;
    while dprod lt #A do
        dmin +:= 1;
        dprod *:= dmin;
    end while;
    G := Group(A);
    C := ConjugacyClasses(G);
    S := Sym(#C);
    f := ClassMap(G);
    // Have to figure out which classes are joined by automorphisms
    Cact := sub<S|[[f(a(C[i][3])) : i in [1..#C]] : a in Generators(A)]>;
    O := Orbits(Cact);
    O := [o : o in O | o[1] eq 1 or &+[C[i][2] : i in o] gt 1];
    Osizes := [&+[C[i][2] : i in o] : o in O];
    ParallelSort(~Osizes, ~O);
    tups := [tup : tup in CartesianProduct([[1..#O] : _ in [1..n]]) | &and[tup[i] eq 1 or tup[i] lt tup[i+1] : i in [1..#tup-1]] and &*[Osizes[i] : i in tup] le dbound and &*[Osizes[i] : i in tup] ge dmin];
    tupsizes := [&*[Osizes[i] : i in tup] : tup in tups];
    ParallelSort(~tupsizes, ~tups);
    //L := &join[{@ x : x in r^G @} : r in reps];
    if try_union then
        F := [[&join[C[j][3]^G : j in O[i]] : i in tup]: tup in tups];
        L := &cat[[<facs[i][c[i]] : i in [1..#c]> : c in CartesianProduct([[1..#facs[i]] : i in [1..#facs]])] : facs in F];
        S := Sym(#L);
        print "Start", #L;
        GG := [];
        indexer := AssociativeArray();
        for i in [1..#L] do
            indexer[L[i]] := i;
        end for;
        GG := [[ indexer[<a(g) : g in gtup>] : gtup in L ] : a in Generators(A)];
        print "End";
        H := sub<S|GG>;
        if #H eq #A then
            print "success";
            return H;
        end if;
        print "fail";
        return G;
    end if;
    for tup in tups do
        print [O[i] : i in tup];
        facs := [&join[C[j][3]^G : j in O[i]] : i in tup];
        L := [<facs[i][c[i]] : i in [1..#c]> : c in CartesianProduct([[1..#facs[i]] : i in [1..#facs]])];
        S := Sym(#L);
        GG := [[ Index(L, <a(g) : g in gtup>): gtup in L ] : a in Generators(A)];
        H := sub<S|GG>;
        if #H eq #A then
            print "success";
            return H;
        end if;
    end for;
    print "fail";
    return G;
end intrinsic;

intrinsic AutPermRep(A::GrpAuto : dbound:=1000, verbose:=false) -> GrpPerm, MonStgElt
{Gives a permutation representation of A, either a transitive one of degree up to 47 or one of smallest degree}
    t0 := Cputime();
    G := Group(A);
    if Type(G) ne GrpPerm then
        error "AutoPermRep only available for permutation groups";
    end if;
    Sn := Sym(Degree(G));
    N := Normalizer(Sn, G);
    T := Centralizer(Sn, G);
    //if #N eq #T * #A and (#T eq 1 or #A lt 1000000 or IsSolvable(A)) then
    if false then
        // have full automorphism group as N/T
        if verbose then
            print "Normalizer gives full automorphism group";
        end if;
        NtoA := hom<N -> A | [n -> A!hom<G -> G| [g -> n^-1*g*n : g in Generators(G)]> : n in Generators(N)]>;
        AtoN := NtoA^-1;
        if #T eq 1 then
            if IsTransitive(N) and Degree(G) lt 48 then
                M1 := Sprintf("%oPerm%o", Degree(N), Join([Sprint(EncodePerm(AtoN(a))) : a in Generators(N)], ","));
                return N, M1;
            else
                R := N;
                AtoR := AtoN;
            end if;
        elif #A lt 1000000 then
            R, NtoR := quo<N | T>;
            AtoR := AtoN * NtoR;
        else
            NP, NtoNP := PCGroup(N);
            R, NPtoR := quo<NP | NtoNP(T)>;
            AtoR := AtoN * NtoNP * NPtoR;
        end if;
        if verbose then
            printf "Quotient constructed in %o seconds", Cputime() - t0;
        end if;
    else
        Z := Center(G);
        nOut := (#A * #Z) div #G;
        rho := PermutationRepresentation(A);
        P := Codomain(rho);
        dlimit := Ceiling(Degree(P) / nOut);
        if dbound gt dlimit then
            dbound := dlimit;
        end if;
        if verbose then
            printf "G of order %o, with %o inner automorphisms and %o outer classes\n", #G, #G div #Z, nOut;
            printf "Initial permutation representation of degree %o found in %o seconds\n", Degree(P), Cputime() - t0;
            t0 := Cputime();
        end if;
        Phom := hom<G -> P | [g -> rho(A!hom<G -> G| [e -> g^-1*e*g : e in Generators(G)]>) : g in Generators(G)]>;
        dlow := 1;
        while true do
            S := [X : X in LowIndexSubgroups(G, <dlow, dbound>) | IsDivisibleBy(#X, #Z) and Z subset X and Core(G, X) eq Z];
            if verbose then
                printf "Found %o subgroups of index %o-%o with central core in %o seconds\n", #S, dlow, dbound, Cputime() - t0;
                t0 := Cputime();
            end if;
            Sind := [Index(G, X) : X in S];
            ParallelSort(~Sind, ~S);
            broken := false;
            for H in S do
                K := Phom(H);
                if #Core(P, K) eq 1 then
                    if verbose then
                        printf "Found a core-free subgroup with index %o in %o seconds\n", Index(P, K), Cputime() - t0;
                        t0 := Cputime();
                    end if;
                    phi := CosetAction(P, K);
                    R := Image(phi);
                    AtoR := rho * phi;
                    broken := true;
                    break;
                end if;
            end for;
            if broken then break; end if;
            if dbound eq dlimit then
                R := P;
                AtoR := rho;
                break;
            end if;
            dlow := dbound + 1;
            dbound := Min(2*dbound, dlimit);
        end while;
    end if;
    psi := MinimalDegreePermutationRepresentation(R);
    M := Image(psi);
    if verbose then
        printf "Minimized representation in %o seconds; final degree %o\n", Cputime() - t0, Degree(M);
        t0 := Cputime();
    end if;
    F := FewGenerators(M);
    if verbose then
        printf "Minimized number of generators in %o seconds; %o generators\n", Cputime() - t0, #F;
        t0 := Cputime();
    end if;
    M0 := sub<Sym(Degree(M))|F>;
    M1 := Sprintf("%oPerm%o", Degree(M), Join([Sprint(EncodePerm(psi(AtoR(a)))) : a in Generators(A)], ","));
    return M0, M1;
end intrinsic;

intrinsic ProjMatHom(G, P, L) -> Map
{Returns the homomorphism from the matrix group G to its projectivization P, given the set of lines L on which P acts (returned by the constructor of P)}
    K := CoefficientRing(G);
    images := [];
    lookup := AssociativeArray();
    for i in [1..#L] do
        x := L[i];
        for c in K do
            if c ne 0 then
                lookup[c*x] := i;
            end if;
        end for;
    end for;
    return hom<G -> P | [<g, P![lookup[x^g] : x in L]> : g in Generators(G)]>;
end intrinsic;
